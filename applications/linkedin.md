As an ex-hardware engineer, I’ve built systems of all sizes. I’ve worked with the minute in transistors and microcontrollers and the gigantic in spacecraft and robots. Thus, I know the impact each individual component has on the whole. Likewise, I know the importance of understanding how the complete system works before working on its subsystems. I have been able to carry this knowledge into Software Development. My attention to detail is vital in debugging small snippets of code that are integral to my program. I am able to easily pinpoint bugs and errors by isolating specific components and snippets of code, which is a skill I directly transferred from my circuit debugging abilities. I also know the importance of clean and streamlined code. A huge issue in a few of the companies I worked with was the inability to find specific components and parts because of poor practices and storage management which led to hours of wasted time. Because of my experiences, I always aim for cleanliness. A messy program or directory tree can waste the time of all engineers involved. Another one of my strenghts is my ability to see the overeall system and how the component I am working on fits in. At one of my jobs, I was working on a series of pick-and-drop robots. I needed to understand how the motor or controller I was working on would impact how the robot functions. Depending on how fast we wanted the system to run or how much weight it needed pick up, we needed specify the strength of the motor and voltage sent out by the controller. This carries well into software design. Once I identify what I want my system to do, I know how each component should behave in certain situations. Having a clear, concise game plan is important in writing clean and efficient code.

My understanding of these _____ has helped me with my communication between different teams. Even though two departments may work on the same project, they do not understand the same concepts and the limitations the other party has. In the roles I have worked at before, I often acted as the bridge between two groups successfully. This is highlighted by my time at Aerojet Rocketdyne. One of the first projects I worked on there was on an electrical system used to power a future space mission. When I started working there, it was near the end of the project. I had to talk with component engineers and relay information over towards system engineers and vice versa. Although they worked on the same projects, their communication was very weak since they dealt with such different scopes. I recognized their weak communication and decided to double-check their designs to make sure that everything was properly made and functional. Upon reading their schematics and diagrams, I realized that the voltage for one of the parts was incorrect. Upon further investigation, I saw that the component was actually completely the wrong one. I brought this up to my manager at that time and he brought it up to both teams. They acknowledged that it was incorrect and we managed to fix the box with the right components required. My willingness to proofread the schematics of a slightly dysfunctional project team saved the company its contract and most likely the jobs of multiple engineers.




Ever since I was a child, I loved technology. I fondly remember sitting in front of my Windows 98 computer playing *Neopets* with my sister in our dimly lit study room. I grew up loving computers and video games and spent many hours on them. In highschool, I decided to take a computer science class to better understand how video games and computers worked. However, this class was detrimental to my passions. The course was introductory and thus its scope was extremely limited. I learned conditional statements, loops and basic object oriented programming, but since I could not mentally connect the things I was learning to my passions, I felt that coding was a chore. However, I was still interested in technology, so out of highschool I decided to major in Electrical Engineering. One of the first courses I took was an introductory C++ course. The final project was a very simple dungeon puzzle game using object oriented programming. I had so much fun building the game from scratch and thinking of creative ways to create unique traps and puzzles. After that class, I was condering switching into computer science but because of the sunk cost fallacy, I decided to stay with Electrical Engineering. However, I was still interested in software so I decided to focus on Digital Signal Processing which combined major facets of both Hardware and Software. In these courses, I found how powerful software could be. I could manipulate any image, video or audio however I wanted. I soon began to study more computer science topics in my free time and became extremely interested in web development. Out of college, I took a hardware engineering job where I designed and built robots. However, I never had the same passion for building hardware as I did developing software. At nights, after work, I would work on small website projects using rudimentary HTML, CSS and JavaScript. After every single project, no matter how small, I would have a sense of accomplishment that I never got from hardware projects, no matter the scale. I decided to pursue this passion, left my job and attended the coding bootcamp App Academy up in San Francisco. Here, I properly learned the fundamentals of web development. I learned how to setup databases, link together the backend and frontend and create a clean and beautiful UI/UX. Many people look down upon bootcamps but I feel that the experience was rewarding and invaluable.

Recently, I have been learning Python when I am not studying for interviews. Python is currently one of the most prevalent languages in the industry and I believe that it will help my job search. Like most engineers, I learn new topics much better by doing, not watching or reading. However, I know the importance of having a strong foundation before tackling a question or issue. So, when I started learning Python, I purchased a course online that went over the fundamentals of Python and studied it closely. I'm glad I did as the course covered python-specific funtionalities like decorators, iterators and generators. After acquiring a firm base of knowledge, I've used Python for any new problems or projects that I work on. I have been doing all coding challenges and interviews I received in Python to constantly keep the syntax fresh in my head. Now, writing Python is as natural for me as writing JavaScript and Ruby which were the two languages that App Academy had us use for over three months. I am a do-er and that is really the best way for me to learn.

As a young engineer who recently finished college, I know that my current knowledge is extremely shallow. Like I said earlier, I learn by doing. Whenever I learn a new topic or technology, I look to apply it wherever I can. Whether it may be a creating a new project, improving an old project or even writing a small function, I look at use what I learn wherever I can. I often read or hear about new technologies that can replace the ones I currently use and I quickly do my research and them to a small queue in my head. The next technologies I plan on learning are GraphQL and React Hooks. I plan on incorporating both of these to my current projects to see the effect on it and the pros and cons it can bring. In the future, I do want to go into technical project management. I believe that after years of constantly expanding my repertoire, I will have enough experience to recommend what technologies to use and how to use them in the situation. However, with my mindset, I will be constantly open to new tools that can further and help the project as it scales into the future. My openess to try new things and my ability to grasp them well will help me in my software career.




One of the projects I am most proud is Dunder (Link: http://dunder-app.herokuapp.com/; Github: https://github.com/TimothyJao/Dunder/). Dunder is a clone of the Discord messaging app inspired by "*The Office*". It uses a PostgresQL database with a Ruby on Rails server and a React.js/Redux frontend. This project was the culmination of my learning at App Academy and was the first fullstack project I have ever worked on. By far, the hardest part of the project was understanding how to integrate the backend server with the frontend components. It was a struggle to understand how the redux cycle tied together the frontend components, the website's state and api calls. However, once I created a couple components, it became easier to understand how the cycle worked and adding new components became faster. 

I had to incorporate completely foreign technologies such as Ruby on Rail's ActionCable to my project (Link for ActionRail setup on frontend and backend: https://repl.it/@TimothyJao/ActionCable-setup). ActionCable utilizes web sockets to allow for live events to happen. In my case, I used it to implement live chat. For me, understanding how web sockets worked was half the battle. I had to read and watch countless articles and videos before I could grasp exactly how they worked and what output I should expect from them. However, once I was able to understand, the implementation was straight forward. I had to create a new table in my database to store the messages and setup sockets on both my frontend and backend that would listen for messages to be sent out and received. On the backend.rb file, you can see the socket being set up in the subscribed function in like 3-6. In the backend sockets, there are two main functions called speak and load. The speak will preform an action once there is data sent from the frontend and then broadcast it to the rest of the frontend sockets. The load will then send the message to the backend to be stored into the database. On the frontend, 

I also decided to implement a search function in my website. The actual search and autocomplete functionality was simple to setup. When a change in the searchbar happened, it would call an action which sends an AJAX request to the backend. The backend then grabs the information needed and sends a response back to the frontend. The redux state is then updated and the react component is updated as a result. This worked perfectly for me but the UX/UI was extremely choppy since the autocomplete would be called as soon as any change would happen. I did some research and found that there were two main ways to improve this issue is through debouncing or throttling. I decided on debouncing which is when the function does not run until a certain amount of time passes. I decided to try to create my own, simple debouncing function on my own and this is my result (Link to debounce function and how it would be used: https://repl.it/@TimothyJao/debounce). This debounce function returns a function that will return a setTimeout that will run the function after a set amount of time. However, if this debounce function is called again before the time passes, it will clear the setTimeout and reinstantiate a new one which is done in lines 5-7. To use the debounce function, you can merely call the debounce function with the function you want to run as one parameter and the time between as the other parameter.